<!DOCTYPE html>
<html>
<head>
  <title>Road-Based Route Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <style>
    body, html { margin:0; padding:0; height:100%; }
    #map { height: 80%; width: 100%; }
    #controlsPanel { padding: 10px; }
    input[readonly] { width: 150px; margin-right: 10px; }
    button { margin-right: 5px; }
  </style>
</head>
<body>

<div id="map"></div>
<div id="controlsPanel">
  Lat: <input type="text" id="latField" readonly>
  Lng: <input type="text" id="lngField" readonly>
  <button id="pinModeBtn">Enable Pin Mode</button>
  <button id="btnSaveRoute">Save Route</button>
  <button id="btnClearTags">Clear Route</button>
  <input type="text" id="routeNameInput" placeholder="Route Name">
  <select id="savedRoutesDropdown">
    <option value="">Select a saved route</option>
  </select>
  <button id="btnStartNavigation">Start Navigation</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>

<script>
let map, userMarker, watchId;
let taggedPoints = [];
let taggedMarkers = [];
let taggedRouteLine = null;
let routingControl = null;
let pinMode = false;
let savedRoutes = {};

// Custom icons
const redIcon = L.icon({
  iconUrl: "https://cdn-icons-png.flaticon.com/512/1077/1077114.png",
  iconSize: [25,41], iconAnchor:[12,41], popupAnchor:[1,-34]
});
const taggedIcon = L.icon({
  iconUrl: "https://cdn-icons-png.flaticon.com/512/684/684908.png",
  iconSize:[30,30], iconAnchor:[15,30], popupAnchor:[0,-30]
});

// Initialize map
function initMap() {
  map = L.map("map").setView([10.7905,78.7047], 14); // Trichy default

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "Â© OpenStreetMap contributors"
  }).addTo(map);

  // Map click for pin mode
  map.on("click", function(e){
    if(!pinMode) return;
    addTaggedPoint([e.latlng.lat,e.latlng.lng], "Pinned Point " + (taggedPoints.length+1));
  });
}

// Add tagged point
function addTaggedPoint(latlng,label){
  taggedPoints.push(latlng);
  const marker = L.marker(latlng,{icon:taggedIcon}).addTo(map).bindPopup(label);
  marker.openPopup();
  taggedMarkers.push(marker);
}

// Update user location fields and marker
function updateUserLocation(pos){
  const lat = pos.coords.latitude;
  const lng = pos.coords.longitude;
  document.getElementById("latField").value = lat.toFixed(6);
  document.getElementById("lngField").value = lng.toFixed(6);

  if(userMarker) userMarker.setLatLng([lat,lng]);
  else userMarker = L.marker([lat,lng],{icon:redIcon}).addTo(map).bindPopup("You are here").openPopup();

  map.panTo([lat,lng]);
}

// Pin Mode toggle
document.getElementById("pinModeBtn").addEventListener("click",()=>{
  pinMode = !pinMode;
  document.getElementById("pinModeBtn").textContent = pinMode ? "Disable Pin Mode" : "Enable Pin Mode";
});

// Clear route
document.getElementById("btnClearTags").addEventListener("click",()=>{
  taggedPoints = [];
  taggedMarkers.forEach(m=>map.removeLayer(m));
  taggedMarkers = [];
  if(taggedRouteLine) map.removeLayer(taggedRouteLine);
  taggedRouteLine = null;
  if(routingControl){ map.removeControl(routingControl); routingControl=null; }
});

// Save route
document.getElementById("btnSaveRoute").addEventListener("click",()=>{
  const name = document.getElementById("routeNameInput").value.trim();
  if(!name){ alert("Enter route name"); return;}
  if(taggedPoints.length<2){ alert("Pin at least 2 points"); return;}
  savedRoutes[name] = taggedPoints.slice();
  localStorage.setItem("savedRoutes", JSON.stringify(savedRoutes));
  updateSavedRoutesDropdown();
  document.getElementById("routeNameInput").value = "";
  alert("Route saved");
});

// Load saved routes dropdown
function loadSavedRoutes(){
  const saved = localStorage.getItem("savedRoutes");
  if(saved){ savedRoutes = JSON.parse(saved); updateSavedRoutesDropdown(); }
}
function updateSavedRoutesDropdown(){
  const dropdown = document.getElementById("savedRoutesDropdown");
  dropdown.innerHTML = '<option value="">Select a saved route</option>';
  Object.keys(savedRoutes).forEach(name=>{
    const option = document.createElement("option");
    option.value = name; option.textContent = name;
    dropdown.appendChild(option);
  });
}

// Load selected route
document.getElementById("savedRoutesDropdown").addEventListener("change",()=>{
  const name = document.getElementById("savedRoutesDropdown").value;
  if(!name) return;
  taggedPoints = savedRoutes[name].slice();
  taggedMarkers.forEach(m=>map.removeLayer(m));
  taggedMarkers = [];
  taggedPoints.forEach((p,i)=>{
    const marker = L.marker(p,{icon:taggedIcon}).addTo(map).bindPopup("Point "+(i+1));
    taggedMarkers.push(marker);
  });
  if(taggedRouteLine) map.removeLayer(taggedRouteLine);
  taggedRouteLine = L.polyline(taggedPoints,{color:'green',weight:4}).addTo(map);
  map.fitBounds(taggedRouteLine.getBounds(),{padding:[30,30]});
});

// TSP optimization (nearest neighbour)
function optimizeRoute(start, points){
  const remaining = points.slice();
  const ordered = [];
  let current = start;
  while(remaining.length>0){
    let minIdx=0, minDist=haversineDistance(current,remaining[0]);
    for(let i=1;i<remaining.length;i++){
      const dist = haversineDistance(current,remaining[i]);
      if(dist<minDist){ minDist=dist; minIdx=i; }
    }
    const next = remaining.splice(minIdx,1)[0];
    ordered.push(next);
    current = next;
  }
  return ordered;
}

// Haversine distance
function haversineDistance(a,b){
  const R=6371000;
  const lat1=a[0]*Math.PI/180, lat2=b[0]*Math.PI/180;
  const dLat=lat2-lat1;
  const dLon=(b[1]-a[1])*Math.PI/180;
  const x=Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2);
  return R*2*Math.atan2(Math.sqrt(x),Math.sqrt(1-x));
}

// Start Navigation
document.getElementById("btnStartNavigation").addEventListener("click",()=>{
  if(taggedPoints.length<1){ alert("No points to navigate"); return; }
  if(!userMarker){ alert("User location not found"); return; }

  const startLatLng = [userMarker.getLatLng().lat,userMarker.getLatLng().lng];
  const orderedPoints = optimizeRoute(startLatLng,taggedPoints);

  const waypoints = [L.latLng(...startLatLng)];
  orderedPoints.forEach(p=>waypoints.push(L.latLng(...p)));

  if(routingControl){ map.removeControl(routingControl); routingControl=null; }

  routingControl = L.Routing.control({
    waypoints: waypoints,
    router: L.Routing.osrmv1({serviceUrl:'https://router.project-osrm.org/route/v1'}),
    lineOptions: {styles:[{color:'green',weight:5}]},
    createMarker:function(i,wp,n){ return L.marker(wp.latLng,i===0?{icon:redIcon}:{icon:taggedIcon}); },
    addWaypoints:false,
    fitSelectedRoutes:true,
    draggableWaypoints:false,
    routeWhileDragging:false
  }).addTo(map);
});

// Watch user location
if(navigator.geolocation){
  navigator.geolocation.getCurrentPosition(updateUserLocation);
  watchId = navigator.geolocation.watchPosition(updateUserLocation);
}

initMap();
loadSavedRoutes();
</script>

</body>
</html>
